*阅读《深入理解C++对象模型》的笔记*

# 对象的布局

对一个普通的C++类，如：

```C++
struct Base {
    int val1, val2；
    char val3;
};
```

其在内存中的布局和C语言的`struct`结构兼容，即布局如下：

```
----------
|        | 4 bytes
|  val1  |
----------
|        | 4 bytes
|  val2  |
----------
|  val3  | 1 byte
----------
|        | 3 bytes
----------
```

其中3字节的由于对齐规则编译器额外插入的。可以看到，简单的C++类型的布局很简单。但是如果这个时候，我们给Base加上一个虚函数，同让一个Derived集成Base，那么Base和Derived对象在内存中的布局会变得怎么样呢？

```C++
struct Base {
    int val1, val2;
    char val3;
    virtual void print_val() { ... }
};

struct Derived: public Base {
    char val4;
    virtual void print_val() { ... }
};
```

C++将所有的non-static成员放在对象中，子类继承了父类的成员变量，同时子类还有自己的成员变量。对于虚函数，父类和子类都有自己的实现，C++用一个虚函数表来存储类的所有虚函数地址，同时在对象内存存储一个虚函数表指针，用以指向虚函数表。于是内存布局就有如下的形式：

```
Base                                         Derived
----------              --------------     -----------                --------------
|        | -----------> |            |     |         |--------------> |            |
|  vptr  | 4 bytes      |  print_val |     |   vptr  | 4 bytes        |  print_val |
----------              --------------     -----------                --------------
|        | 4 bytes                         |         |
|  val1  |                                 |   val1  | 4 bytes
----------                                 -----------
|        | 4 bytes                         |         |
|  val2  |                                 |   val2  | 4 bytes
----------                                 -----------
|  val3  | 1 byte                          |  val3   | 1 byte
----------                                 -----------
|        | 3 bytes                         | 3 bytes |
----------                                 -----------
                                           |  val4   | 1 byte
                                           -----------
                                           | 3 bytes |
                                           -----------

注：假设指针的大小为4个字节
```
注意到在Derived中，父类因为对齐而被插入的3个字节并没有在子类中消除，或我们觉得子类的那一个byte应该父类那一个byte合并，然后只需要2个字节来对齐即可，但是考虑这样一种情况：

```C++
Base b = ...;
Derived d = b;
```

此时如果两个char合并了，那么得到的Derived对象的val4就会被Base中用于补齐的字节所填补，而这个值并不是我们所想要的。

对于`vptr`，它可以放在对象的头部，也可以放在对象的末尾，甚至于穿插在对象变量之间，但是放在头部有这么一个优点：对于Derived对象指pd，`pd -> print_val()`语句并不需要在编译期重新计算函数的地址，否则在编译器对虚函数的调用就会变成`(pd + sz) -> ptint_val()`，缺点就是类型和c的struct类型不兼容。

试想一下如果Base没有virtual函数而Derived有virtual函数会发生什么？对于下列操作：

```C++
Derived d;
Base* pb = &d;
```

由于Base对象不会有`vptr`，而Derived对象有`vptr`，那么对于Base对象成员的存取以及函数调用就必须编译器的介入以重新计算每一个对象成员的地址。这也就告诉我们给基类型定义一个虚析构函数是很有帮助的。

这里再提一下成员对象指针。例如，Base的成员val1的指针类型为：`int Base::*`,如我们打印该指针的值，输出为4，即成员对象的指针为该成员在对象内部的偏移量。这里有一个问题，如果Base不含virtual，我们怎么能区分一个不知指向任何成员的指针（值为0）和指向第一个成员的指针（值也为0）呢？`cfront`所做的是将指向成员对象的指针加1，那么指向成员的指针的值就会变成如1,5，9等。（GCC则是做了特殊处理，指针的值仍然为0,4,8等）

# 编译器生成的构造函数

对一个普通的C++类，如：

```C++
struct Point {
    int x, y;
};
```

我们知道的是编译器会自动为`Point`生成一个构造函数，函数结构两个整型作为参数。编译器只在需要生成构造函数是为类型生成一个构造函数，但是什么时候是需要的呢主要有两个条件：

1. 类的成员对象有默认构造函数
2. 类有虚函数或者父类有虚函数

对于这样一个类：

```C++
class Object {
public:
    Object1 obj1;
    Object2 obj2;
    int val;
};
```

假设Object1和Object2有默认构造函数，那么在下面的程序中

```C++
Object Obj;
```

编译器就会因为需要Object的默认构造函数而为Object生成一个构造函数，函数的代码类似如下：

```C++
class Object {
public:
    Object() {
        this -> obj1.Object1::Object1();
        this -> obj2.Object2::Object2();
    }
};
```

编译器忽略了val成员的初始化，即编译器只为那些需要调用默认构造函数成员调用默认构造函数。可以看出，编译器会试图初始化所有成员变量，只要改成员变量有默认构造函数，编译器就会试图去调用它。

对于有虚函数的类，编译器会为其生成默认构造函数的原因是因为必须正确设置vptr。

如果用户自定义了构造函数，那么编译器不会为其生成构造函数，那编译器如何为需要调用默认构造函数的所有成员调用构造函数以及设置vptr呢？答案就是在用户定义的构函数里插入代码。

# 编译器生成的Copy构造函数

规则：
```
如果对象的成员对象有默认的copy构造函数或者是有虚函数出现，那么编译器就会为其构造copy构造函数，否则就会实施`bitwise copy`。
```

举个例子来说：
```C++
struct A {
    B b;
    C c;
    int val;
};

struct C {
    int c;
};

struct B {
    int val;
    B(const B& b) {...}
};

struct V {
    virtual xxx() {}
};
```

编译器会为A和V分别生成一个拷贝构造函数。对于A来说，只有其对象b调用了B的拷贝构造函数，其余成员都是经由一个`bitwise copy`进行拷贝。对于V来说，拷贝构造函数主要是为了正确设置vptr。

